# AI Assistant Rules for PollApp Project

This file contains project-specific rules and patterns to help AI assistants understand the structure, conventions, and expectations of the PollApp Next.js polling application.

## 📁 Project Structure Rules

### File Organization
- **Pages**: Use Next.js 15 App Router structure in `src/app/`
- **Components**: Organize in `src/components/` with feature-based folders
- **Hooks**: Custom hooks in `src/hooks/` with descriptive names starting with `use`
- **Types**: All TypeScript types in `src/types/index.ts`
- **Database**: Supabase client configs in `src/lib/supabase/`
- **Styles**: Global styles in `src/app/globals.css`, component styles inline with Tailwind

### Required Folder Structure
```
src/
├── app/                    # Next.js App Router pages
│   ├── auth/              # Authentication pages
│   ├── polls/             # Poll-related pages
│   ├── dashboard/         # User dashboard
│   └── api/               # API routes (future)
├── components/
│   ├── ui/                # Shadcn/UI components
│   ├── auth/              # Auth-specific components
│   ├── polls/             # Poll-specific components
│   └── layout/            # Layout components
├── hooks/                 # Custom React hooks
├── lib/
│   └── supabase/          # Supabase configurations
└── types/                 # TypeScript type definitions
```

## 🎨 UI/UX Component Rules

### Shadcn/UI Usage
- **ALWAYS** use Shadcn/UI components for consistent design
- **Import pattern**: `import { Button } from "@/components/ui/button"`
- **Available components**: Button, Card, Input, Label, Alert, Badge, Progress, Tabs, etc.
- **Icons**: Use Lucide React icons only: `import { Plus, User, Settings } from "lucide-react"`

### Component Structure
```typescript
"use client"; // Only for client components

import { ComponentName } from "@/components/ui/component-name";
import { Icon } from "lucide-react";
import { useHookName } from "@/hooks/use-hook-name";

interface ComponentProps {
  // Define props with TypeScript
}

export function ComponentName({ prop1, prop2 }: ComponentProps) {
  // Component logic
  return (
    <Card className="w-full">
      {/* JSX content */}
    </Card>
  );
}
```

### Styling Rules
- **Primary**: Use Tailwind CSS classes exclusively
- **Responsive**: Always include responsive classes (sm:, md:, lg:)
- **Dark mode**: Use semantic colors (primary, secondary, muted, etc.)
- **Spacing**: Consistent spacing with Tailwind (space-y-4, gap-6, p-4, etc.)

## 🔐 Authentication Rules

### Supabase Auth Pattern
- **Context**: Always use `AuthProvider` wrapper in root layout
- **Hooks**: Use `useAuth()` hook for auth operations
- **Protected Routes**: Wrap with `<RequireAuth>` or `<GuestOnly>`
- **User Data**: Access via `user` object from Supabase (not custom AuthUser type)

### Auth Component Structure
```typescript
"use client";

import { useAuth } from "@/hooks/use-auth";
import { useRouter } from "next/navigation";

export function AuthComponent() {
  const { user, signIn, signOut, loading } = useAuth();
  const router = useRouter();

  const handleAction = async () => {
    try {
      await signIn(credentials);
      router.push("/dashboard");
    } catch (error: any) {
      setError(error.message);
    }
  };

  return (
    // JSX with error handling and loading states
  );
}
```

### Route Protection
- **Dashboard, Create Poll**: Must use `<RequireAuth>`
- **Login, Register**: Must use `<GuestOnly>`
- **Public pages**: No wrapper needed

## 🗄️ Database & API Rules

### Supabase Client Usage
- **Client-side**: Use `createClient()` from `@/lib/supabase/client`
- **Server-side**: Use `createClient()` from `@/lib/supabase/server`
- **Types**: Import Supabase types: `import { User } from "@supabase/supabase-js"`

### Database Schema Rules
- **Tables**: profiles, polls, poll_options, votes, poll_participants
- **RLS**: All tables have Row Level Security enabled
- **Foreign Keys**: Always reference auth.users(id) for user relationships
- **UUIDs**: Use UUID primary keys, generated with gen_random_uuid()

### Data Fetching Pattern
```typescript
const { data, error } = await supabase
  .from('table_name')
  .select('column1, column2')
  .eq('user_id', user.id)
  .order('created_at', { ascending: false });

if (error) throw new Error(error.message);
```

## 🔄 State Management Rules

### Custom Hooks
- **Naming**: Always start with `use` (useAuth, usePolls, useProfile)
- **Return**: Return object with data, loading, error, and actions
- **Error Handling**: Always include error states and throw meaningful errors
- **Loading States**: Include loading states for async operations

### Hook Structure Template
```typescript
export function useFeatureName() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const actionName = async (params) => {
    try {
      setLoading(true);
      setError(null);
      // Async operation
      setData(result);
    } catch (err: any) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  return { data, loading, error, actionName };
}
```

## 📝 Form Handling Rules

### Form Component Pattern
- **No external form libraries**: Use native React state and form handling
- **Validation**: Both client-side and server-side validation required
- **Error Display**: Use Alert component from Shadcn/UI
- **Loading States**: Disable form during submission with loading prop from hooks
- **User Feedback**: Show loading spinners and success/error messages
- **Hook Integration**: Use custom hooks for data operations instead of inline logic

### Form Structure Template
```typescript
export function FormComponent() {
  const [formData, setFormData] = useState({ field1: "", field2: "" });
  const [error, setError] = useState<string | null>(null);
  const { actionFunction, loading } = useCustomHook();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);

    // Validation
    if (!formData.field1) {
      setError("Field is required");
      return;
    }

    try {
      await actionFunction(formData);
      // Handle success
    } catch (err: any) {
      setError(err.message);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      {/* Form fields */}
      <Button type="submit" disabled={loading}>
        {loading ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
        Submit
      </Button>
    </form>
  );
}
```

## 🎯 TypeScript Rules

### Type Definitions
- **Location**: All types in `src/types/index.ts`
- **Naming**: Use PascalCase for interfaces
- **Imports**: Import types with `import type { TypeName } from "@/types"`
- **Supabase**: Extend Supabase types when needed

### Required Type Patterns
```typescript
// User types - extend Supabase User
export interface User extends SupabaseUser {
  username?: string;
  display_name?: string;
}

// Form data types
export interface CreatePollData {
  title: string;
  description?: string;
  options: string[];
  expiresAt?: Date;
  allowMultipleVotes?: boolean;
  isAnonymous?: boolean;
}

// Component prop types
export interface ComponentProps {
  required: string;
  optional?: number;
  children?: React.ReactNode;
}
```

## 🚀 Performance & Best Practices

### Component Optimization
- **Client Components**: Only use "use client" when necessary (hooks, events, form interactions)
- **Server Components**: Default for static content and initial data fetching
- **Loading States**: Always show loading indicators for async operations via hook state
- **Error Boundaries**: Handle errors gracefully with user-friendly messages
- **API Integration**: Use both direct Supabase calls and API routes for complex operations
- **Data Validation**: Implement validation in both hooks and API routes

### Code Quality Rules
- **Imports**: Use absolute imports with `@/` prefix
- **Naming**: Use descriptive names for functions and variables
- **Comments**: Add JSDoc comments for complex functions
- **Destructuring**: Destructure props and hook returns
- **Early Returns**: Use early returns for validation and error cases

## 🧪 Testing Considerations

### Component Testing Patterns
- **Render Testing**: Test component renders without errors
- **User Interactions**: Test form submissions and button clicks
- **Hook Testing**: Test custom hooks with React Testing Library
- **Auth States**: Test both authenticated and unauthenticated states

## 📱 Responsive Design Rules

### Breakpoint Usage
- **Mobile First**: Start with mobile design, add larger breakpoints
- **Breakpoints**: sm: (640px), md: (768px), lg: (1024px), xl: (1280px)
- **Grid**: Use grid system for layouts: `grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3`
- **Spacing**: Responsive spacing: `p-4 md:p-6 lg:p-8`

## 🔍 Common Patterns to Follow

### Page Component Structure
```typescript
// For client pages with authentication
"use client";

import { RequireAuth } from "@/components/auth/protected-route";
import { PageContent } from "./page-content";

export default function PageName() {
  return (
    <RequireAuth>
      <div className="min-h-screen bg-background py-8 px-4">
        <div className="container mx-auto">
          <PageContent />
        </div>
      </div>
    </RequireAuth>
  );
}
```

### API Route Structure
```typescript
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    
    // Authentication check
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: "Authentication required" }, { status: 401 });
    }

    // Parse and validate data
    const data = await request.json();
    const validation = validateData(data);
    if (!validation.isValid) {
      return NextResponse.json({ error: validation.errors[0] }, { status: 400 });
    }

    // Database operations
    const { data: result, error } = await supabase
      .from("table_name")
      .insert([data])
      .select()
      .single();

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ success: true, data: result });
  } catch (error) {
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
```

### Error Handling Pattern
```typescript
const handleAction = async () => {
  try {
    setLoading(true);
    setError(null);
    await someAsyncAction();
    // Success handling
  } catch (err: any) {
    setError(err.message || "Something went wrong");
  } finally {
    setLoading(false);
  }
};
```

## ❌ Anti-Patterns to Avoid

1. **Don't** use external form libraries (react-hook-form, formik) - use native React
2. **Don't** create custom UI components - use Shadcn/UI
3. **Don't** use CSS modules or styled-components - use Tailwind only
4. **Don't** export metadata from client components
5. **Don't** use localStorage for auth - let Supabase handle it
6. **Don't** skip validation in API routes - always validate server-side
7. **Don't** mix authentication patterns - stick to Supabase Auth
8. **Don't** put complex business logic directly in components - use custom hooks
9. **Don't** forget cleanup operations in database transactions
10. **Don't** use hardcoded limits - define constants for validation rules

## 🔄 When Scaffolding New Features

### Step-by-Step Process
1. **Types**: Define TypeScript interfaces in `src/types/index.ts`
2. **Hook**: Create custom hook in `src/hooks/use-feature-name.ts`
3. **Components**: Build UI components with Shadcn/UI
4. **Page**: Create page component with proper routing
5. **Protection**: Add authentication wrappers if needed
6. **Testing**: Test the complete user flow

### Example: Creating a Poll Feature
```typescript
// 1. Add types to src/types/index.ts
export interface NewPollData {
  title: string;
  options: string[];
}

// 2. Create hook src/hooks/use-create-poll.ts
export function useCreatePoll() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const createPoll = async (data: CreatePollData) => {
    try {
      setLoading(true);
      setError(null);
      // Supabase operations with transaction handling
      // Include cleanup on failure
      return result;
    } catch (err: any) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  return { createPoll, loading, error, validatePollData };
}

// 3. Create component src/components/polls/create-poll-form.tsx
export function CreatePollForm() {
  // Form implementation
}

// 4. Create page src/app/polls/create/page.tsx
export default function CreatePollPage() {
  return (
    <RequireAuth>
      <CreatePollForm />
    </RequireAuth>
  );
}
```

## 📋 Implementation Checklist

When creating new features, verify:

- [ ] **Types defined** in `src/types/index.ts`
- [ ] **Custom hook created** with proper error handling and loading states
- [ ] **Validation implemented** in both client and server (if API route exists)
- [ ] **Database operations** use transactions where needed
- [ ] **Authentication checks** in place for protected operations
- [ ] **Error cleanup** implemented for failed operations
- [ ] **Loading states** handled in UI components
- [ ] **Responsive design** included with proper breakpoints
- [ ] **Shadcn/UI components** used consistently
- [ ] **Route protection** applied where appropriate

## 🔄 Validation Rules

### Client-Side Validation
- Text length limits (title: 200, description: 1000, options: 200)
- Required field checks
- Array length limits (options: 2-10)
- Date validation for future dates
- Input sanitization (trim whitespace)

### Server-Side Validation
- Same rules as client-side for security
- Database constraint validation
- Authentication verification
- Input type checking
- SQL injection prevention

---

**Remember**: These rules ensure consistency, maintainability, and adherence to the project's architectural decisions. Always follow these patterns when adding new features or modifying existing code. Test validation on both client and server sides, and always implement proper error handling with cleanup operations.